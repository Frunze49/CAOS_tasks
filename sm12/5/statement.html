<html><head><meta charset="utf-8"/></head>
<body>
<table border="1"><tr><td><b>Time limit:</b></td><td><tt>1 s</tt></td></tr>
<tr><td><b>Real time limit:</b></td><td><tt>5 s</tt></td></tr>
<tr><td><b>Memory limit:</b></td><td><tt>64M</tt></td></tr>
</table>
<h3>Problem sm12-5: cxx/concurrency/fibers</h3>
<p><a href="https://gist.github.com/ObjatieGroba/f197c54e2f7aa54ecb4d582e3dacf784">Реализуйте</a>
            функции помеченные TODO так, чтобы тесты прошли.</p>
<p>Ваша задача реализовать файберы - это легковесный поток (нить) выполнения,
            который работает в рамках одного процесса и использует общую область памяти с другими потоками (нитями).</p>
<p>Файберы будут сами решать когда им можно уступить выполнение другой нити используя функцию <code>yield</code> (кооперативная многозадачность).</p>
<p>Центральной точкой работы файберов является планировщик (FiberScheduler), позволяющий накапливать очередь,
            а также исполняющий накопленные нити по вызову функции <code>run</code>.</p>
<p>Так как файберы это независимые друг от друга по исполнению функции - они обязаны иметь свои собственные колстек и стек.</p>
<p> </p>
<p>Action - специально сообщение от файбера к планировщику и обратно для управления последним. (А еще передачи аргумента, что будет далее.)</p>
<p>Изучите функцию <code>run_fiber</code> - это точка входа в нить (трамплин). Функция принимает единственный аргумент - FiberKeeper.
            По завершению нити из функции трамплин переключаемся в планировщик, сообщая о завершении. (Почему нельзя сделать return из трамплина?)</p>
<p>Напишите функцию <code>switch_context</code>. Функция будет содержать ОДНУ вставку (в других функциях вставки не нужны).
            Функция переключает текущее исполнение на сохраненное в структуре.
            С помощью этой и только этой функции мы будем переключать выполнение.
            <code>switch_context</code> должен сохранять все необходимые регистры и при переключении,
            но в самой структуре нет необходимости в иных полях кроме представленных.
            Для переключения eip рекомендуются инструкции `call *reg` или `ret`.
            ASM вставка будет состоять из двух логических частей - до прыжка (первая часть) и после (вторая часть).
            Когда и как мы оказываемся во второй части (что предшествует исполнению кода второй части)?
            Какие <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">clobbers</a> необходимо прописать?
            <code>memory</code>? <code>cc</code>? Нужна ли инструкция
            <a href="https://www.felixcloutier.com/x86/mfence.html#:~:text=The%20MFENCE%20instruction%20provides%20a,WC%2C%20and%20WT%20memory%20types.">mfence</a>
            с учетом, что на самом деле мы все исполняем линейно в одном и том же потоке?</p>
<p>Yield переключает выполнение на другую нить если такая нить существует.</p>
<p>FiberKeeper (std::function) содержит нетривиальный конструктор и деструктор.
            Используйте memcpy и memset, чтобы избежать двойного вызова деструктора и передать аргумент внутрь файбера.
            Альтернативным решением может стать конструирование FiberKeeper через new по указателю (не на куче).</p>
<p>Метод switch_context меняет местами текущее исполнение и "сохраненное" в структуре.</p>
<p><a href="https://www.agner.org/optimize/calling_conventions.pdf">Соглашение о вызовах. 6 Register usage. SSE регистры можно портить!</a></p>
<p>Обратите внимание, что run_fiber принимает на самом деле (по C++ decl) указатель на fiber, а не саму структуру.
            Тем не менее советую положить структуру рядом - до указателя.</p>
<p>Тесты и функция main в тестирующей системе не отличаются кроме теста <code>test_secret</code>, тело которого вам неизвестно.</p>
<p>Для использования меток внутри inline asm <a href="https://stackoverflow.com/a/16095781">ссылка</a>.</p>
<p>Обратите внимание на InlineScheduler запускающий файберы незамедлительно. Этот планировщик проходит несколько тестов.</p>
<p>Ваш код будет скомпилирован с флагом <code>-O2</code></p>
<p>В качестве ответа необходимо прислать только реализации функций:</p>
<pre>
void FiberScheduler::Context::switch_context() {
    ...
}

void FiberScheduler::schedule(Fiber fiber) {
    ...
}

void FiberScheduler::yield() {
    ...
}

void FiberScheduler::run() {
    ...
}
    </pre>
<p> </p></body></html>