<html><head><meta charset="utf-8"/></head>
<body>
<table border="1"><tr><td><b>Time limit:</b></td><td><tt>4 s</tt></td></tr>
<tr><td><b>Real time limit:</b></td><td><tt>5 s</tt></td></tr>
<tr><td><b>Memory limit:</b></td><td><tt>64M</tt></td></tr>
</table>
<h3>Problem fibers-1: cxx/concurrency/generator</h3>
<h3>ДИСКЛЕЙМЕР</h3>
<p>Эта задача покажется вам знакомой. Вам не кажется.
                Данная задача более дружелюбная и одновременно усложненная реинкарнация прошлой.</p>
<h3>Файберы. Генераторы.</h3>
<p>
<a href="https://gist.github.com/ObjatieGroba/143a06f33a5e9634d560950c6983c929">Реализуйте</a>
                функции помеченные TODO так, чтобы тесты прошли.
            </p>
<p>Ваша задача реализовать файберы - это легковесный поток (нить) выполнения,
                который работает в рамках одного процесса и использует общую область памяти с другими потоками (нитями).</p>
<p>Файберы будут сами решать когда им можно уступить выполнение другой нити используя функцию <code>yield</code> (кооперативная многозадачность).</p>
<p>Центральной точкой работы файберов является планировщик (FiberScheduler), позволяющий накапливать очередь,
                а также исполняющий накопленные нити по вызову функции <code>run</code>.</p>
<p>Так как файберы это независимые друг от друга по исполнению функции - они обязаны иметь свои собственные колстек и стек.</p>
<p>Файберы должны быть легковесными - их работа не должна вызывать обращения к ОС (поэтому ucontext.h запрещен).</p>
<h3>Часть 1. Это база.</h3>
<p>Action - специально сообщение от файбера к планировщику и обратно для управления последним. (А еще передачи аргумента, что будет далее.)</p>
<p>Изучите функцию <code>trampoline</code> - это точка входа в нить. Функция принимает единственный аргумент - указатель на нить, содержащуюся в Context.
                По завершению нити из функции трамплин переключаемся в планировщик, сообщая о завершении. Дорабатывать функцию на этом этапе не требуется.
                (Почему нельзя сделать return из трамплина?)</p>
<p>Допишите функцию <code>FiberScheduler::create_context_from_fiber</code>. Эта функция подготавливает контекст первого запуска нити.
                (Не помню, а с чего должен начинаться запуск файбера?)
                Советую адресом возврата явно положить <code>nullptr</code>, это упростит дебаг в дальнейшем.
                Для каста <code>intptr_t</code> используйте <code>reinterpret_cast</code>.</p>
<p>Допишите функцию <code>Context::switch_context</code>. Это база. Функция будет содержать ОДНУ вставку (в других функциях вставки не нужны).
                Функция переключает текущее исполнение на сохраненное в структуре, а также пробрасывает сквозь себя action.
                С помощью этой и только этой функции мы будем переключать выполнение.
                <code>switch_context</code> должен сохранять все необходимые регистры и при переключении,
                но в самой структуре нет необходимости в иных полях кроме представленных.
                Для переключения eip рекомендуются инструкции `call *reg` или `ret`.
                ASM вставка будет состоять из двух логических частей - до прыжка (первая часть) и после (вторая часть).
                Когда и как мы оказываемся во второй части (что предшествует исполнению кода второй части)?
                Какие <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">clobbers</a> необходимо прописать?
                <code>memory</code>? <code>cc</code>?  Нужна ли инструкция
                <a href="https://www.felixcloutier.com/x86/mfence.html#:~:text=The%20MFENCE%20instruction%20provides%20a,WC%2C%20and%20WT%20memory%20types.">mfence</a>?</p>
<p><a href="https://www.agner.org/optimize/calling_conventions.pdf">Соглашение о вызовах. 6 Register usage. Какие регистры нужно сохранять? Почему можно не думать о SSE регистрах?</a></p>
<p>Допишите функцию <code>FiberScheduler::run</code> наивно. Исключения и ревизоры (Watch) пока не потребуются.</p>
<p>На этом этапе у вас начнут проходить первые тесты!</p>
<h3>Часть 2. Yield. Рекурсивный планировщик.</h3>
<p>Допишите функцию <code>FiberScheduler::yield</code>. А при чём здесь Action::user_data?</p>
<p>Допишите функцию <code>scheduler_run</code> так чтобы вызов планировщика в планировщике не приводил к ошибке.
                Почему сделана отдельная функция? Почему нельзя просто <code>scheduler-&gt;run()</code>?</p>
<h3>Часть 3. Исключения.</h3>
<p>Исключения - специальный механизм C++. При запуске исключение происходит раскрутка стека до тех пор, пока мы не встретим <code>try-except</code>.</p>
<p>Что будет если бросить исключение внутри файбера?</p>
<p>Допишите функции <code>trampoline</code>, <code>FiberScheduler::run</code> и <code>scheduler_run</code> так,
                чтобы исключение выброшенное в нити пробросилось наружу в планировщик.</p>
<p>На этом этапе должны проходить все тесты до <code>test_recursive_sched_exc</code> включительно</p>
<h3>Часть 4. Генераторы.</h3>
<p>Наша цель - добиться поведения как у <a href="https://wiki.python.org/moin/Generators">Python</a>.</p>
<p>Простая реализация - генератор внутри итератора создаёт внутри новый планировщик и каждый раз продолжает исполнение контекста до следующей остановки.
                Обращу внимание, что by design Context переносим между планировщиками, поэтому можно создавать каждый раз новый планировщик.</p>
<p>Генератор будет принимать некоторую функцию из которой по yield значения передаются в итератор (без накопления массива значений).
                Каждое разыменование итератора - новое значение переданное функцией.</p>
<p>Итератор должен знать место остановки - когда функция переданная в генератор завершила исполнение,
                поэтому предлагается всегда в итераторе хранить следующее значение <code>next_</code>.</p>
<p>Данный класс практически написан за вас - вам остаётся только заполнить пробелы.</p>
<p>Для этого нам помогут ревизоры (a.k.a. инспекторы a.k.a. Watch). Наследники этого класса
                <a href="https://gist.github.com/ObjatieGroba/143a06f33a5e9634d560950c6983c929#file-generators-cpp-L232">могут</a>
                подписываться на события перехода текущего потока в планировщик и менять эти события на своё усмотрение.</p>
<p>Вопрос на понимание - что произойдет в результате выполнения <code>create_current_fiber_watch&lt;SomeWatch&gt;(); yield()</code>?</p>
<p> </p>
<p>Допишите функцию <code>update</code>. Функция запускает очередную итерацию генератора.</p>
<p>Допишите функцию <code>GeneratorWatch::operator()</code> - ревизор предназначенный для остановки выполнения функции генератора.
                Мы его уже привязали к контексту генератора в конструкторе <code>Iterator</code>.</p>
<p>Допишите функцию <code>FiberScheduler::run</code> вызывая ревизора при наличии.</p>
<h3>Полезное.</h3>
<p>Тесты в тестирующей системе не отличаются.</p>
<p>Для использования меток внутри inline asm <a href="https://stackoverflow.com/a/16095781">ссылка</a>.</p>
<p>Ваш код будет скомпилирован с флагами<code>-Wall -Werror -Wa,--fatal-warnings -O2 -g -m32</code></p>
<p>Valgrind поможет отловить невалидные обращения к памяти.</p>
<p>В качестве ответа необходимо прислать только реализации функций
                <a href="https://gist.github.com/ObjatieGroba/143a06f33a5e9634d560950c6983c929#file-generators-cpp-L200">с</a>
<a href="https://gist.github.com/ObjatieGroba/143a06f33a5e9634d560950c6983c929#file-generators-cpp-L348">по</a>:</p>
<pre>
    template &lt;class Result&gt;
    class Generator;

    Action Context::switch_context(Action action);
    void trampoline(Fiber *fiber);
    void scheduler_run(FiberScheduler &amp;sched);
    Context FiberScheduler::create_context_from_fiber(Fiber fiber);
    void *FiberScheduler::yield(void *data);
    void FiberScheduler::run();
            </pre>
<p> </p></body></html>